---
layout: post
title: CRTP初探
date: 2026-01-13 10:50:00 +0800
description: CRTP设计模式初探
tags:
  - Design Pattern
  - Template
---

## CRTP

CRTP，全称“Curiously Recurring Template Pattern”（怪异递归模板模式），
是一种在C++编程中使用模板的设计模式。这种模式看起来有点不寻常，但非常强大和实用。
它的核心思想是：一个类将自己作为模板参数传递给基类。

第一次看到这个模式的时候，确实感觉很怪异，毕竟直觉上直接继承可以做到功能，为什么要反其道而行之，
使用模板，破坏代码的可读性呢？但深入了解后才发现他的好处。

首先我们来看一下正常继承关系的一个简单示例：

```c++
// Base.h
class Base {
public:
    virtual void foo() {
        // 基类实现
    }
};

// Derived.h
class Derived : public Base {
public:
    void foo() override {
        // 子类实现
    }
};
```

可以看到，正常情况下，编译器会为每一个带有虚函数的类生成对应的虚函数表，以满足运行时的多态性。

然后我们来看一下CRTP是如何做到的：

```c++
template <typename Derived>
class Base {
public:
    void interface() {
        // 调用派生类实现的方法
        static_cast<Derived*>(this)->implementation();
    }

    // 派生类必须实现这个方法
    void implementation() {
        // 默认实现（如果需要的话）
    }
};

class Derived : public Base<Derived> {
public:
    void implementation() {
        // Derived类自己的实现
        std::cout << "Derived implementation" << std::endl;
    }
};

int main() {
    Derived d;
    d.interface(); // 输出: Derived implementation
}
```

这时，CRTP的优点就体验出来，使用模板之后，其提供了一种无需运行时开销的多态性，
因为类型在编译时就已经确定，所以也并不会使用虚函数表，可以减少内存和时间的开销。
除此之外，由于CRTP实现了编译时多态性，编译器可以在编译时进行更多的优化，
如内联展开（inline expansion），这可以显著提高运行时性能。

不过，由于模板的特性，导致单纯的CRTP，无法使用基类指针储存，这在程序设计中算是一个硬伤，
具体可以通过以下情况缓解：

```C++
class IBase {
public:
    virtual ~IBase() = default;
    virtual void interface() = 0;
};

template <typename Derived>
class Base : public IBase {
public:
    void interface() override {
        static_cast<Derived*>(this)->implementation();
    }
};
```

但是同样的，由于引入了虚函数，导致CRTP的性能优势会丢失一部分，不过最差情况下，也与直接使用虚函数相当。

同时，如果不考虑性能的需求，CRTP还有一个好处，因为它传入了子类的类型，使得基类阶段就已经明确子类类型，
从而实现很多正常编程无法做的特性，比如VSG(VulkanSceneGraph)中，就使用Inherit基类，它的主要代码是这样的：

```C++
template<class ParentClass, class Subclass>
class Inherit : public ParentClass
{
public:
    template<typename... Args>
    Inherit(Args&&... args) :
        ParentClass(std::forward<Args>(args)...) {}

    template<typename... Args>
    static ref_ptr<Subclass> create(Args&&... args)
    {
        return ref_ptr<Subclass>(new Subclass(std::forward<Args>(args)...));
    }

    template<typename... Args>
    static ref_ptr<Subclass> create_if(bool flag, Args&&... args)
    {
        if (flag) return ref_ptr<Subclass>(new Subclass(std::forward<Args>(args)...));
        return {};
    }

    std::size_t sizeofObject() const noexcept override { return sizeof(Subclass); }
    const char* className() const noexcept override { return type_name<Subclass>(); }
    const std::type_info& type_info() const noexcept override { return typeid(Subclass); }
    bool is_compatible(const std::type_info& type) const noexcept override { return typeid(Subclass) == type || ParentClass::is_compatible(type); }

    int compare(const Object& rhs) const override
    {
        int result = ParentClass::compare(rhs);
        if (result != 0) return result;

        size_t startOfSubclass = sizeof(ParentClass);
        size_t size = sizeof(Subclass) - startOfSubclass;

        // Subclass adds no extra data to compare
        if (size == 0) return 0;

        const char* lhs_ptr = reinterpret_cast<const char*>(this);
        const char* rhs_ptr = reinterpret_cast<const char*>(&rhs);

        // compare the data that Subclass adds over ParentClass
        return std::memcmp(lhs_ptr + startOfSubclass, rhs_ptr + startOfSubclass, size);
    }

    void accept(Visitor& visitor) override { visitor.apply(static_cast<Subclass&>(*this)); }
    void accept(ConstVisitor& visitor) const override { visitor.apply(static_cast<const Subclass&>(*this)); }
    void accept(RecordTraversal& visitor) const override { visitor.apply(static_cast<const Subclass&>(*this)); }
};
```

由于使用了CRTP，子类很多需要反复重载的函数，如`sizeofObject`这种函数在子类中就可以完全不写，大大减少样板代码。